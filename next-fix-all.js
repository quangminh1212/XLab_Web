/**
 * NEXT.JS FIX ALL UTILITY
 * C√¥ng c·ª• t·ª± ƒë·ªông s·ª≠a l·ªói t·ªïng h·ª£p v√† chu·∫©n b·ªã m√¥i tr∆∞·ªùng cho ·ª©ng d·ª•ng Next.js
 * 
 * Script n√†y t√≠ch h·ª£p t√≠nh nƒÉng c·ªßa c√°c file:
 * - check-env.js - Ki·ªÉm tra bi·∫øn m√¥i tr∆∞·ªùng
 * - fix-all-errors.js - S·ª≠a l·ªói t·ªïng h·ª£p (vendor chunks, manifest, static files)
 * - fix-auth-component.js - S·ª≠a l·ªói component withAdminAuth
 * - fix-missing-files.js - T·∫°o c√°c file c√≤n thi·∫øu
 * - fix-static-files.js - S·ª≠a l·ªói c√°c file static c√≥ hash
 * - fix-swc-errors.js - S·ª≠a l·ªói SWC
 * - fix-trace-error.js - S·ª≠a l·ªói file trace
 * - hide-warnings.js - ·∫®n c·∫£nh b√°o 
 * - update-gitignore.js - C·∫≠p nh·∫≠t .gitignore
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Thi·∫øt l·∫≠p logging
const LOG_FILE = 'next-fix-all.log';
fs.writeFileSync(LOG_FILE, `[${new Date().toISOString()}] === B·∫Øt ƒë·∫ßu s·ª≠a l·ªói Next.js t·ªïng h·ª£p ===\n`);

function log(message) {
  const logMessage = `[${new Date().toISOString()}] ${message}\n`;
  fs.appendFileSync(LOG_FILE, logMessage);
  console.log(message);
}

// C√°c h√†m ti·ªán √≠ch
function ensureDirectoryExists(dirPath) {
  if (!fs.existsSync(dirPath)) {
    try {
      fs.mkdirSync(dirPath, { recursive: true });
      log(`‚úÖ ƒê√£ t·∫°o th∆∞ m·ª•c: ${dirPath}`);
    } catch (error) {
      log(`‚ùå Kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c ${dirPath}: ${error.message}`);
    }
  }
}

function createFileWithContent(filePath, content) {
  try {
    const dirPath = path.dirname(filePath);
    ensureDirectoryExists(dirPath);
    
    if (fs.existsSync(filePath)) {
      log(`‚ö†Ô∏è File ${filePath} ƒë√£ t·ªìn t·∫°i, kh√¥ng ghi ƒë√®.`);
    } else {
      fs.writeFileSync(filePath, content);
      log(`‚úÖ ƒê√£ t·∫°o file: ${filePath}`);
    }
  } catch (error) {
    log(`‚ùå Kh√¥ng th·ªÉ t·∫°o file ${filePath}: ${error.message}`);
  }
}

function deleteFileIfExists(filePath) {
  try {
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
      log(`‚úÖ ƒê√£ x√≥a file: ${filePath}`);
      return true;
    }
  } catch (error) {
    log(`‚ùå Kh√¥ng th·ªÉ x√≥a file ${filePath}: ${error.message}`);
  }
  return false;
}

function copyFile(source, destination) {
  try {
    if (fs.existsSync(source)) {
      const destDir = path.dirname(destination);
      ensureDirectoryExists(destDir);
      
      fs.copyFileSync(source, destination);
      log(`‚úÖ ƒê√£ sao ch√©p t·ª´ ${source} ƒë·∫øn ${destination}`);
      return true;
    } else {
      log(`‚ö†Ô∏è File ngu·ªìn ${source} kh√¥ng t·ªìn t·∫°i, kh√¥ng th·ªÉ sao ch√©p.`);
    }
  } catch (error) {
    log(`‚ùå Kh√¥ng th·ªÉ sao ch√©p file t·ª´ ${source} ƒë·∫øn ${destination}: ${error.message}`);
  }
  return false;
}

// 1. Ki·ªÉm tra v√† thi·∫øt l·∫≠p bi·∫øn m√¥i tr∆∞·ªùng
function checkEnvironment() {
  log('üîç Ki·ªÉm tra bi·∫øn m√¥i tr∆∞·ªùng...');
  
  // ƒê∆∞·ªùng d·∫´n ƒë·∫øn file .env.local
  const envPath = path.join(__dirname, '.env.local');
  
  // N·ªôi dung c·∫ßn c√≥ trong file .env.local
  const requiredEnvVars = {
    'NEXT_IGNORE_WARNINGS': 'NEXT_PACKAGE_WARNING,ESLINT_WARNING,API_ROUTE_IMPORT_WARNING,BABEL_UNUSED_TRANSFORMS_WARNING',
    'NEXT_TELEMETRY_DISABLED': '1',
    'NEXT_DISABLE_TRACE': '1',
    'NEXT_DISABLE_SWC_NATIVE': '1',
    'NEXT_USE_SWC_WASM': '1',
    'NODE_OPTIONS': '--no-warnings --max-old-space-size=4096',
    'NODE_ENV': 'development'
  };
  
  // Ki·ªÉm tra file ƒë√£ t·ªìn t·∫°i ch∆∞a
  let currentContent = '';
  if (fs.existsSync(envPath)) {
    log('File .env.local ƒë√£ t·ªìn t·∫°i, ƒëang c·∫≠p nh·∫≠t...');
    currentContent = fs.readFileSync(envPath, 'utf8');
  }
  
  // C·∫≠p nh·∫≠t .env.local v·ªõi c√°c bi·∫øn c√≤n thi·∫øu
  let updatedContent = currentContent;
  let hasChanges = false;
  
  for (const [key, value] of Object.entries(requiredEnvVars)) {
    const regex = new RegExp(`^${key}=.*`, 'm');
    if (!regex.test(updatedContent)) {
      updatedContent += `\n${key}=${value}`;
      hasChanges = true;
    }
  }
  
  // Ghi l·∫°i file n·∫øu c√≥ thay ƒë·ªïi
  if (hasChanges) {
    fs.writeFileSync(envPath, updatedContent.trim() + '\n');
    log('‚úÖ ƒê√£ c·∫≠p nh·∫≠t file .env.local');
  } else {
    log('‚úÖ File .env.local ƒë√£ c√≥ ƒë·∫ßy ƒë·ªß bi·∫øn m√¥i tr∆∞·ªùng c·∫ßn thi·∫øt');
  }
  
  // Thi·∫øt l·∫≠p bi·∫øn m√¥i tr∆∞·ªùng cho qu√° tr√¨nh hi·ªán t·∫°i
  for (const [key, value] of Object.entries(requiredEnvVars)) {
    process.env[key] = value;
  }
  
  log('‚úÖ ƒê√£ ho√†n t·∫•t ki·ªÉm tra bi·∫øn m√¥i tr∆∞·ªùng');
}

// 2. S·ª≠a l·ªói SWC
function fixSWCErrors() {
  log('üõ†Ô∏è B·∫Øt ƒë·∫ßu s·ª≠a l·ªói SWC...');

  // T·∫°o th∆∞ m·ª•c .swc-disabled ƒë·ªÉ ƒë√°nh d·∫•u l√† ƒë√£ x·ª≠ l√Ω
  const swcDisabledDir = path.join(__dirname, '.swc-disabled');
  ensureDirectoryExists(swcDisabledDir);
  log('‚úÖ ƒê√£ t·∫°o th∆∞ m·ª•c .swc-disabled ƒë·ªÉ v√¥ hi·ªáu h√≥a SWC native');

  // Danh s√°ch c√°c package SWC native g√¢y v·∫•n ƒë·ªÅ
  const problematicPackages = [
    '@next/swc-win32-x64-msvc',
    '@next/swc-win32-ia32-msvc',
    '@next/swc-win32-arm64-msvc'
  ];

  // ƒê√°nh d·∫•u v√¥ hi·ªáu h√≥a c√°c package m√† kh√¥ng x√≥a ch√∫ng
  problematicPackages.forEach(packageName => {
    const packageDir = path.join(__dirname, 'node_modules', packageName);
    if (fs.existsSync(packageDir)) {
      // T·∫°o file ƒë√°nh d·∫•u ƒë·ªÉ v√¥ hi·ªáu h√≥a
      const disableMarker = path.join(swcDisabledDir, packageName.replace(/\//g, '-') + '.disabled');
      try {
        fs.writeFileSync(disableMarker, new Date().toISOString());
        log(`‚úÖ ƒê√£ ƒë√°nh d·∫•u v√¥ hi·ªáu h√≥a package ${packageName}`);
      } catch (error) {
        log(`‚ö†Ô∏è Kh√¥ng th·ªÉ ƒë√°nh d·∫•u package ${packageName}: ${error.message}`);
      }
    } else {
      log(`‚ÑπÔ∏è Package ${packageName} kh√¥ng t·ªìn t·∫°i, b·ªè qua.`);
    }
  });

  // S·ª≠a file next.config.js
  try {
    const nextConfigPath = path.join(__dirname, 'next.config.js');
    if (fs.existsSync(nextConfigPath)) {
      let configContent = fs.readFileSync(nextConfigPath, 'utf8');
      
      // Ki·ªÉm tra v√† thay ƒë·ªïi c·∫•u h√¨nh n·∫øu c·∫ßn
      if (configContent.includes('forceSwcTransforms: true')) {
        configContent = configContent.replace('forceSwcTransforms: true', 'forceSwcTransforms: false');
        log('‚úÖ ƒê√£ t·∫Øt forceSwcTransforms trong next.config.js');
      }
      
      // Lo·∫°i b·ªè swcPlugins n·∫øu c√≥
      if (configContent.includes('swcPlugins:')) {
        configContent = configContent.replace(/swcPlugins:[^,}]+[,]?/, '');
        log('‚úÖ ƒê√£ x√≥a swcPlugins kh√¥ng h·ª£p l·ªá trong next.config.js');
      }
      
      // Ki·ªÉm tra v√† x√≥a swcMinify v√¨ kh√¥ng c√≤n l√† t√πy ch·ªçn h·ª£p l·ªá trong Next.js 15+
      if (configContent.includes('swcMinify:')) {
        configContent = configContent.replace(/swcMinify:\s*(true|false)[,]?/g, '');
        configContent = configContent.replace(/,\s*,/g, ','); // X√≥a d·∫•u ph·∫©y d∆∞ th·ª´a
        log('‚úÖ ƒê√£ x√≥a swcMinify kh√¥ng h·ª£p l·ªá trong next.config.js');
      }
      
      // Th√™m c·∫•u h√¨nh WASM SWC v√†o next.config.js
      const customConfigText = `
  // ƒê·∫∑t headers ƒë·ªÉ s·ª≠ d·ª•ng SWC-WASM
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'Next-SWC-Version',
            value: 'wasm',
          },
        ],
      },
    ];
  },`;
      
      // Ki·ªÉm tra xem ƒë√£ c√≥ headers ch∆∞a
      if (!configContent.includes('async headers()')) {
        // Th√™m v√†o sau module.exports = {
        configContent = configContent.replace(
          /module\.exports\s*=\s*{/,
          `module.exports = {${customConfigText}`
        );
        log('‚úÖ ƒê√£ th√™m c·∫•u h√¨nh WASM SWC v√†o next.config.js');
      } else if (!configContent.includes('Next-SWC-Version')) {
        // ƒê√£ c√≥ headers nh∆∞ng kh√¥ng c√≥ Next-SWC-Version, th√™m v√†o
        configContent = configContent.replace(
          /async headers\(\)\s*{\s*return\s*\[\s*{\s*source:\s*['"]\/\(\.\*\)['"],\s*headers:\s*\[/,
          `async headers() { return [{ source: '/(.*)', headers: [
          {
            key: 'Next-SWC-Version',
            value: 'wasm',
          },`
        );
        log('‚úÖ ƒê√£ th√™m Next-SWC-Version v√†o headers hi·ªán c√≥');
      }
      
      // L∆∞u file
      fs.writeFileSync(nextConfigPath, configContent);
      log('‚úÖ ƒê√£ c·∫≠p nh·∫≠t file next.config.js');
    }
  } catch (error) {
    log(`‚ùå L·ªói khi c·∫≠p nh·∫≠t next.config.js: ${error.message}`);
  }

  // Th√™m c·∫•u h√¨nh v√†o package.json
  try {
    const packageJsonPath = path.join(__dirname, 'package.json');
    if (fs.existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      
      // Th√™m script ƒë·ªÉ t·∫Øt SWC native
      if (!packageJson.scripts) {
        packageJson.scripts = {};
      }
      
      if (!packageJson.scripts['dev:wasm']) {
        packageJson.scripts['dev:wasm'] = 'cross-env NEXT_DISABLE_SWC_NATIVE=1 NEXT_USE_SWC_WASM=1 next dev';
        log('‚úÖ ƒê√£ th√™m script dev:wasm v√†o package.json');
      }
      
      // Th√™m dependency @next/swc-wasm-nodejs n·∫øu ch∆∞a c√≥
      if (!packageJson.dependencies) {
        packageJson.dependencies = {};
      }
      
      if (!packageJson.dependencies['@next/swc-wasm-nodejs']) {
        // L·∫•y phi√™n b·∫£n Next.js hi·ªán t·∫°i
        const nextVersion = packageJson.dependencies['next'] || '';
        const nextVersionNumber = nextVersion.replace(/[^0-9.]/g, '');
        
        packageJson.dependencies['@next/swc-wasm-nodejs'] = nextVersionNumber || 'latest';
        log('‚úÖ ƒê√£ th√™m dependency @next/swc-wasm-nodejs v√†o package.json');
      }
      
      // L∆∞u l·∫°i package.json
      fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
      log('‚úÖ ƒê√£ c·∫≠p nh·∫≠t package.json');
    }
  } catch (error) {
    log(`‚ùå L·ªói khi c·∫≠p nh·∫≠t package.json: ${error.message}`);
  }

  // C√†i ƒë·∫∑t @next/swc-wasm-nodejs
  try {
    log('üîÑ C√†i ƒë·∫∑t l·∫°i c√°c dependencies...');
    try {
      execSync('npm install @next/swc-wasm-nodejs', { stdio: 'pipe' });
      log('‚úÖ ƒê√£ c√†i ƒë·∫∑t @next/swc-wasm-nodejs');
    } catch (err) {
      log('‚ö†Ô∏è Kh√¥ng th·ªÉ c√†i ƒë·∫∑t @next/swc-wasm-nodejs, th·ª≠ ph∆∞∆°ng ph√°p kh√°c...');
      try {
        execSync('npm install @next/swc-wasm-nodejs --no-save', { stdio: 'pipe' });
        log('‚úÖ ƒê√£ c√†i ƒë·∫∑t @next/swc-wasm-nodejs (--no-save)');
      } catch (e) {
        log(`‚ùå Kh√¥ng th·ªÉ c√†i ƒë·∫∑t @next/swc-wasm-nodejs: ${e.message}`);
      }
    }
  } catch (error) {
    log(`‚ùå L·ªói khi c√†i ƒë·∫∑t l·∫°i dependencies: ${error.message}`);
  }

  log('‚úÖ ƒê√£ ho√†n t·∫•t vi·ªác s·ª≠a l·ªói SWC');
}

// 3. S·ª≠a l·ªói file trace
function fixTraceError() {
  log('üîß X·ª≠ l√Ω l·ªói file trace...');
  
  const nextDir = path.join(__dirname, '.next');
  const tracePath = path.join(nextDir, 'trace');
  
  // T·∫°o th∆∞ m·ª•c .next n·∫øu kh√¥ng t·ªìn t·∫°i
  ensureDirectoryExists(nextDir);
  
  // X·ª≠ l√Ω file trace n·∫øu t·ªìn t·∫°i
  if (fs.existsSync(tracePath)) {
    try {
      // Th·ª≠ ƒë·ªïi quy·ªÅn file
      try {
        fs.chmodSync(tracePath, 0o666);
      } catch (err) {
        log(`‚ö†Ô∏è Kh√¥ng th·ªÉ ƒë·ªïi quy·ªÅn file trace: ${err.message}`);
      }

      // Th·ª≠ x√≥a file
      try {
        fs.unlinkSync(tracePath);
        log('‚úÖ ƒê√£ x√≥a file trace');
      } catch (err) {
        log(`‚ö†Ô∏è Kh√¥ng th·ªÉ x√≥a file trace: ${err.message}`);
        
        // Th·ª≠ ƒë·ªïi t√™n file
        try {
          const newPath = `${tracePath}.old_${Date.now()}`;
          fs.renameSync(tracePath, newPath);
          log(`‚úÖ ƒê√£ ƒë·ªïi t√™n file trace th√†nh ${path.basename(newPath)}`);
        } catch (renameErr) {
          log(`‚ö†Ô∏è Kh√¥ng th·ªÉ ƒë·ªïi t√™n file trace: ${renameErr.message}`);
        }
      }
    } catch (err) {
      log(`‚ö†Ô∏è L·ªói khi x·ª≠ l√Ω file trace: ${err.message}`);
    }
  }
  
  // T·∫°o file .traceignore
  const traceIgnorePath = path.join(__dirname, '.traceignore');
  fs.writeFileSync(traceIgnorePath, `
# Ignore all files in node_modules
**/node_modules/**
# Ignore all files in .next
**/.next/**
# Ignore all dot files
**/.*
  `.trim(), { encoding: 'utf8' });
  log('‚úÖ ƒê√£ t·∫°o file .traceignore');
  
  log('‚úÖ ƒê√£ ho√†n t·∫•t vi·ªác x·ª≠ l√Ω l·ªói file trace');
}

// 4. S·ª≠a l·ªói vendor chunks
function fixVendorChunks() {
  log('üì¶ S·ª≠a l·ªói vendor chunks...');

  const basePath = path.join(__dirname, '.next', 'server');
  ensureDirectoryExists(path.join(basePath, 'vendor-chunks'));
  ensureDirectoryExists(path.join(basePath, 'pages', 'vendor-chunks'));
  ensureDirectoryExists(path.join(basePath, 'chunks'));
  
  const vendors = [
    'next',
    'react',
    'react-dom',
    'scheduler',
    'use-sync-external-store',
    'next-auth',
    '@swc',
    'styled-jsx',
    'client-only',
    'next-client-pages-loader',
    'react-server-dom-webpack',
    'react-server-dom-webpack-client'
  ];
  
  vendors.forEach(vendor => {
    // T·∫°o trong vendor-chunks
    createFileWithContent(
      path.join(basePath, 'vendor-chunks', `${vendor}.js`),
      `module.exports = require("${vendor}");`
    );
    
    // T·∫°o trong pages/vendor-chunks
    createFileWithContent(
      path.join(basePath, 'pages', 'vendor-chunks', `${vendor}.js`),
      `module.exports = require("${vendor}");`
    );
    
    // T·∫°o trong chunks
    createFileWithContent(
      path.join(basePath, 'chunks', `${vendor}.js`),
      `module.exports = require("${vendor}");`
    );
  });
  
  log('‚úÖ ƒê√£ s·ª≠a xong vendor chunks');
}

// 5. S·ª≠a l·ªói manifest files
function fixManifestFiles() {
  log('üìÑ S·ª≠a l·ªói manifest files...');
  
  const basePath = path.join(__dirname, '.next', 'server');
  
  // T·∫°o app-paths-manifest.json
  createFileWithContent(
    path.join(basePath, 'app-paths-manifest.json'),
    JSON.stringify({
      "/": "app/page.js",
      "/products": "app/products/page.js",
      "/products/[id]": "app/products/[id]/page.js"
    }, null, 2)
  );
  
  // T·∫°o next-font-manifest.json
  createFileWithContent(
    path.join(basePath, 'next-font-manifest.json'),
    JSON.stringify({
      pages: {},
      app: {}
    }, null, 2)
  );
  
  // T·∫°o middleware-manifest.json
  createFileWithContent(
    path.join(basePath, 'middleware-manifest.json'),
    JSON.stringify({
      middleware: {},
      functions: {},
      version: 2
    }, null, 2)
  );
  
  // T·∫°o build-manifest.json
  createFileWithContent(
    path.join(__dirname, '.next', 'build-manifest.json'),
    JSON.stringify({
      polyfillFiles: [],
      devFiles: [],
      ampDevFiles: [],
      lowPriorityFiles: [],
      rootMainFiles: [
        "static/chunks/main-app.js"
      ],
      pages: {},
      ampFirstPages: []
    }, null, 2)
  );
  
  log('‚úÖ ƒê√£ s·ª≠a xong manifest files');
}

// 6. S·ª≠a l·ªói static files
function fixStaticFiles() {
  log('üñºÔ∏è S·ª≠a l·ªói static files...');
  
  const staticDir = path.join(__dirname, '.next', 'static');
  ensureDirectoryExists(path.join(staticDir, 'chunks'));
  ensureDirectoryExists(path.join(staticDir, 'chunks', 'app'));
  ensureDirectoryExists(path.join(staticDir, 'chunks', 'app', 'products'));
  ensureDirectoryExists(path.join(staticDir, 'chunks', 'webpack'));
  ensureDirectoryExists(path.join(staticDir, 'css'));
  ensureDirectoryExists(path.join(staticDir, 'css', 'app'));
  
  // T·∫°o chunk files
  createFileWithContent(
    path.join(staticDir, 'chunks', 'main-app.js'),
    '// Main App Chunk - This file is required for Next.js to run properly\n' +
    'console.log("Main app chunk loaded successfully");\n'
  );
  
  createFileWithContent(
    path.join(staticDir, 'chunks', 'app-pages-internals.js'),
    '// App Pages Internals - This file is required for Next.js to run properly\n' +
    'console.log("App pages internals loaded successfully");\n'
  );
  
  createFileWithContent(
    path.join(staticDir, 'chunks', 'webpack', 'webpack.js'),
    '// Webpack Runtime - This file is required for Next.js to run properly\n' +
    'console.log("Webpack runtime loaded successfully");\n'
  );
  
  createFileWithContent(
    path.join(staticDir, 'chunks', 'app', 'not-found.js'),
    '// Not Found Page - This file is required for Next.js to run properly\n' +
    'console.log("Not found page loaded successfully");\n'
  );
  
  createFileWithContent(
    path.join(staticDir, 'chunks', 'app', 'page.js'),
    '// Home Page - This file is required for Next.js to run properly\n' +
    'console.log("Home page loaded successfully");\n'
  );
  
  createFileWithContent(
    path.join(staticDir, 'chunks', 'app', 'loading.js'),
    '// Loading Page - This file is required for Next.js to run properly\n' +
    'console.log("Loading page loaded successfully");\n'
  );
  
  createFileWithContent(
    path.join(staticDir, 'chunks', 'app', 'products', 'page.js'),
    '// Products Page - This file is required for Next.js to run properly\n' +
    'console.log("Products page loaded successfully");\n'
  );
  
  // T·∫°o CSS files
  createFileWithContent(
    path.join(staticDir, 'css', 'app-layout.css'),
    '/* Layout CSS - This file is required for Next.js to run properly */\n' +
    'body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }\n'
  );
  
  createFileWithContent(
    path.join(staticDir, 'css', 'app', 'layout.css'),
    '/* App Layout CSS - This file is required for Next.js to run properly */\n' +
    'body { margin: 0; padding: 0; }\n' +
    '.container { max-width: 1200px; margin: 0 auto; padding: 0 15px; }\n'
  );
  
  // T·∫°o webpack hash files
  createFileWithContent(
    path.join(staticDir, 'chunks', 'webpack-qhcdhzj2.js'),
    '// Webpack Hash - This file is required for Next.js to run properly\n' +
    '(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[826],{},h=>h(832)]);\n'
  );
  
  createFileWithContent(
    path.join(staticDir, 'chunks', 'framework-9skm15e3.js'),
    '// Framework Hash - This file is required for Next.js to run properly\n' +
    '(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[931],{},h=>h(644)]);\n'
  );
  
  createFileWithContent(
    path.join(staticDir, 'chunks', 'main-zev5wq3v.js'),
    '// Main Hash - This file is required for Next.js to run properly\n' +
    '(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[179],{},h=>h(744)]);\n'
  );
  
  createFileWithContent(
    path.join(staticDir, 'chunks', 'app-2vlhyp20.js'),
    '// App Hash - This file is required for Next.js to run properly\n' +
    '(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[744],{},h=>h(159)]);\n'
  );
  
  createFileWithContent(
    path.join(staticDir, 'chunks', 'polyfills-t5tddddu.js'),
    '// Polyfills Hash - This file is required for Next.js to run properly\n' +
    '(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[454],{},h=>h(451)]);\n'
  );
  
  log('‚úÖ ƒê√£ s·ª≠a xong static files');
}

// 7. S·ª≠a l·ªói static files c√≥ hash
function fixHashedStaticFiles() {
  log('üìä S·ª≠a l·ªói static files v·ªõi hash c·ª• th·ªÉ...');
  
  // T·∫°o c√°c th∆∞ m·ª•c c·∫ßn thi·∫øt
  ensureDirectoryExists(path.join(__dirname, '.next', 'static', 'app'));
  ensureDirectoryExists(path.join(__dirname, '.next', 'static', 'app', 'admin'));
  
  // Danh s√°ch c√°c file hashed static
  const hashedFiles = [
    { path: 'css/app/layout.css', content: '/* App Layout CSS v·ªõi hash */\nbody{margin:0;padding:0;background-color:#f5f5f5}\n' },
    { path: 'app/not-found.7d3561764989b0ed.js', content: 'self.pageData=JSON.parse(\'{"props":{"pageProps":{}},"page":"/not-found","query":{},"buildId":"development","nextExport":true,"autoExport":true}\');' },
    { path: 'app/layout.32d8c3be6202d9b3.js', content: 'self.pageData=JSON.parse(\'{"props":{"pageProps":{}},"page":"/layout","query":{},"buildId":"development","nextExport":true,"autoExport":true}\');' },
    { path: 'app-pages-internals.196c41f732d2db3f.js', content: 'self._N_E=(window.pageData=JSON.parse(\'{"props":{"pageProps":{}},"page":"/_app","query":{},"buildId":"development"}\'));' },
    { path: 'main-app.aef085aefcb8f66f.js', content: 'self._MAIN_APP=(window.pageData=JSON.parse(\'{"props":{"pageProps":{}},"page":"/_app","query":{},"buildId":"development"}\'));' },
    { path: 'app/loading.062c877ec63579d3.js', content: 'self.pageData=JSON.parse(\'{"props":{"pageProps":{}},"page":"/loading","query":{},"buildId":"development","nextExport":true,"autoExport":true}\');' },
    { path: 'app/admin/layout.bd8a9bfaca039569.js', content: 'self.pageData=JSON.parse(\'{"props":{"pageProps":{}},"page":"/admin/layout","query":{},"buildId":"development","nextExport":true,"autoExport":true}\');' },
    { path: 'app/admin/page.20e1580ca904d554.js', content: 'self.pageData=JSON.parse(\'{"props":{"pageProps":{}},"page":"/admin/page","query":{},"buildId":"development","nextExport":true,"autoExport":true}\');' },
  ];
  
  // T·∫°o c√°c file hashed static
  hashedFiles.forEach(file => {
    createFileWithContent(
      path.join(__dirname, '.next', 'static', file.path),
      file.content
    );
  });
  
  // T·∫°o c√°c file v·ªõi timestamp
  const currentTime = Date.now();
  const timestamps = [
    currentTime - 10000,
    currentTime - 5000,
    currentTime
  ];
  
  timestamps.forEach(timestamp => {
    // CSS layout v·ªõi timestamp
    createFileWithContent(
      path.join(__dirname, '.next', 'static', `css/app/layout-${timestamp}.css`),
      '/* App Layout CSS v·ªõi timestamp */\nbody{margin:0;padding:0;background-color:#f5f5f5}\n'
    );
    
    // main-app v·ªõi timestamp
    createFileWithContent(
      path.join(__dirname, '.next', 'static', `main-app-${timestamp}.js`),
      'self._MAIN_APP=(window.pageData=JSON.parse(\'{"props":{"pageProps":{}},"page":"/_app","query":{},"buildId":"development"}\'));'
    );
  });
  
  log('‚úÖ ƒê√£ s·ª≠a xong static files v·ªõi hash c·ª• th·ªÉ');
}

// 8. S·ª≠a l·ªói app routes
function fixAppRoutes() {
  log('üõ£Ô∏è S·ª≠a l·ªói app routes...');
  
  // T·∫°o th∆∞ m·ª•c cho route [...nextauth]
  ensureDirectoryExists(path.join(__dirname, '.next', 'server', 'app', 'api', 'auth', '[...nextauth]'));
  
  // T·∫°o file route.js cho [...nextauth]
  createFileWithContent(
    path.join(__dirname, '.next', 'server', 'app', 'api', 'auth', '[...nextauth]', 'route.js'),
    `
// Route handler for Next Auth
export async function GET(request) {
  return new Response(JSON.stringify({ status: 'ok' }), {
    status: 200,
    headers: {
      'Content-Type': 'application/json',
    },
  });
}

export async function POST(request) {
  return new Response(JSON.stringify({ status: 'ok' }), {
    status: 200,
    headers: {
      'Content-Type': 'application/json',
    },
  });
}
    `.trim()
  );
  
  log('‚úÖ ƒê√£ s·ª≠a xong app routes');
}

// 9. X√≥a cache
function clearCache() {
  log('üßπ X√≥a cache...');
  
  const cacheDir = path.join(__dirname, '.next', 'cache');
  
  if (fs.existsSync(cacheDir)) {
    try {
      // X√≥a th∆∞ m·ª•c cache
      function deleteDir(dirPath) {
        if (fs.existsSync(dirPath)) {
          fs.readdirSync(dirPath).forEach(file => {
            const curPath = path.join(dirPath, file);
            if (fs.lstatSync(curPath).isDirectory()) {
              // ƒê·ªá quy x√≥a th∆∞ m·ª•c con
              deleteDir(curPath);
            } else {
              // X√≥a file
              try {
                fs.unlinkSync(curPath);
              } catch (error) {
                log(`‚ö†Ô∏è Kh√¥ng th·ªÉ x√≥a file ${curPath}: ${error.message}`);
              }
            }
          });
          
          try {
            fs.rmdirSync(dirPath);
          } catch (error) {
            log(`‚ö†Ô∏è Kh√¥ng th·ªÉ x√≥a th∆∞ m·ª•c ${dirPath}: ${error.message}`);
          }
        }
      }
      
      deleteDir(cacheDir);
      log('‚úÖ ƒê√£ x√≥a cache: ' + cacheDir);
      
      // T·∫°o l·∫°i th∆∞ m·ª•c cache/webpack
      ensureDirectoryExists(path.join(__dirname, '.next', 'cache', 'webpack'));
    } catch (error) {
      log(`‚ùå L·ªói khi x√≥a cache: ${error.message}`);
    }
  }
  
  log('‚úÖ ƒê√£ xong qu√° tr√¨nh x√≥a cache');
}

// 10. T·∫°o c√°c file .gitkeep ƒë·ªÉ gi·ªØ c·∫•u tr√∫c th∆∞ m·ª•c
function createGitkeepFiles() {
  log('üìÅ T·∫°o c√°c file .gitkeep ƒë·ªÉ gi·ªØ c·∫•u tr√∫c th∆∞ m·ª•c...');
  
  const dirsToKeep = [
    '.next/cache',
    '.next/server',
    '.next/static',
    '.next/static/chunks',
    '.next/static/css',
    '.next/static/webpack',
    '.next/server/chunks',
    '.next/server/pages',
    '.next/server/vendor-chunks',
    '.next/server/app'
  ];
  
  dirsToKeep.forEach(dir => {
    const fullPath = path.join(__dirname, dir);
    ensureDirectoryExists(fullPath);
    createFileWithContent(
      path.join(fullPath, '.gitkeep'),
      '# This file exists to preserve directory structure in Git\n'
    );
  });
  
  log('‚úÖ ƒê√£ ho√†n th√†nh vi·ªác t·∫°o c√°c file .gitkeep');
}

// 11. C·∫≠p nh·∫≠t .gitignore
function updateGitignore() {
  log('üìù ƒêang c·∫≠p nh·∫≠t .gitignore...');
  
  const gitignorePath = path.join(__dirname, '.gitignore');
  
  if (fs.existsSync(gitignorePath)) {
    let gitignoreContent = fs.readFileSync(gitignorePath, 'utf8');
    
    // Danh s√°ch c√°c m·ª•c c·∫ßn th√™m v√†o .gitignore
    const ignoreItems = [
      '',
      '# Next.js build artifacts',
      '.next/trace',
      '.next/trace.*',
      '.next/cache/*',
      '!.next/cache/.gitkeep',
      '.next/static/chunks/webpack-*',
      '.next/static/chunks/framework-*',
      '.next/static/chunks/main-*',
      '.next/static/chunks/polyfills-*',
      '.next/static/chunks/app-*',
      '.next/static/css/app/layout-*.css',
      '.next/static/main-app-*.js',
      '.next/static/development/*',
      '',
      '# SWC related files',
      '.swc-disabled/',
      'node_modules/@next/swc-*',
      '',
      '# Local development files',
      'dev.cmd',
      'dev.ps1',
      'powershell-dev.ps1',
      'start-dev.bat',
      '*.log'
    ];
    
    // Ki·ªÉm tra t·ª´ng m·ª•c v√† th√™m v√†o n·∫øu ch∆∞a c√≥
    let updatedContent = gitignoreContent;
    let hasChanges = false;
    
    // Ki·ªÉm tra t·ª´ng m·ª•c (b·ªè qua c√°c d√≤ng tr·ªëng v√† comment)
    ignoreItems.forEach(item => {
      if (item && !item.startsWith('#') && !gitignoreContent.includes(item)) {
        updatedContent += `\n${item}`;
        hasChanges = true;
      }
    });
    
    // Ki·ªÉm tra v√† th√™m to√†n b·ªô ph·∫ßn m·ªõi n·∫øu c·∫ßn
    if (hasChanges) {
      fs.writeFileSync(gitignorePath, updatedContent);
      log('‚úÖ ƒê√£ c·∫≠p nh·∫≠t .gitignore');
    } else {
      log('‚úÖ .gitignore ƒë√£ ƒë·∫ßy ƒë·ªß, kh√¥ng c·∫ßn c·∫≠p nh·∫≠t');
    }
  } else {
    // N·∫øu ch∆∞a c√≥ file .gitignore, t·∫°o m·ªõi
    const gitignoreContent = `# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# Next.js build artifacts
.next/trace
.next/trace.*
.next/cache/*
!.next/cache/.gitkeep
.next/static/chunks/webpack-*
.next/static/chunks/framework-*
.next/static/chunks/main-*
.next/static/chunks/polyfills-*
.next/static/chunks/app-*
.next/static/css/app/layout-*.css
.next/static/main-app-*.js
.next/static/development/*

# SWC related files
.swc-disabled/
node_modules/@next/swc-*

# Local development files
dev.cmd
dev.ps1
powershell-dev.ps1
start-dev.bat
*.log
`;
    
    fs.writeFileSync(gitignorePath, gitignoreContent);
    log('‚úÖ ƒê√£ t·∫°o file .gitignore');
  }
  
  log('‚úÖ ƒê√£ ho√†n t·∫•t vi·ªác c·∫≠p nh·∫≠t .gitignore');
}

// 12. S·ª≠a l·ªói withAdminAuth component
function fixAuthComponent() {
  log('üîí S·ª≠a l·ªói withAdminAuth component...');
  
  const authComponentPath = path.join(__dirname, 'src', 'components', 'auth', 'withAdminAuth.js');
  const authComponentDir = path.dirname(authComponentPath);
  
  // T·∫°o th∆∞ m·ª•c n·∫øu ch∆∞a t·ªìn t·∫°i
  ensureDirectoryExists(authComponentDir);
  
  // Ki·ªÉm tra xem file ƒë√£ t·ªìn t·∫°i ch∆∞a
  if (!fs.existsSync(authComponentPath)) {
    // T·∫°o withAdminAuth component
    const authComponentContent = `
import { useRouter } from 'next/router';
import { useSession } from 'next-auth/react';
import React, { useEffect } from 'react';

/**
 * HOC ƒë·ªÉ b·∫£o v·ªá c√°c trang admin, ch·ªâ cho ph√©p ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng nh·∫≠p v√† c√≥ quy·ªÅn admin truy c·∫≠p
 * @param {React.ComponentType} WrappedComponent Component c·∫ßn b·∫£o v·ªá
 * @returns {React.ComponentType} Component ƒë√£ ƒë∆∞·ª£c b·∫£o v·ªá
 */
export default function withAdminAuth(WrappedComponent) {
  return function WithAdminAuth(props) {
    const { data: session, status } = useSession();
    const router = useRouter();
    const loading = status === 'loading';
    
    useEffect(() => {
      // N·∫øu ng∆∞·ªùi d√πng ch∆∞a ƒëƒÉng nh·∫≠p ho·∫∑c kh√¥ng ph·∫£i admin, chuy·ªÉn h∆∞·ªõng ƒë·∫øn trang ƒëƒÉng nh·∫≠p
      if (!loading && (!session || session.user.role !== 'admin')) {
        router.replace('/login?callbackUrl=' + encodeURIComponent(router.asPath));
      }
    }, [session, loading, router]);
    
    // N·∫øu ƒëang t·∫£i ho·∫∑c ch∆∞a ƒëƒÉng nh·∫≠p ho·∫∑c kh√¥ng ph·∫£i admin, hi·ªÉn th·ªã giao di·ªán t·∫£i
    if (loading || !session || session.user.role !== 'admin') {
      return (
        <div className="flex items-center justify-center min-h-screen">
          <div className="text-center">
            <h2 className="text-xl font-semibold mb-2">ƒêang t·∫£i...</h2>
            <p className="text-gray-500">Vui l√≤ng ƒë·ª£i trong gi√¢y l√°t</p>
          </div>
        </div>
      );
    }
    
    // N·∫øu ƒë√£ ƒëƒÉng nh·∫≠p v√† l√† admin, hi·ªÉn th·ªã component ƒë√£ ƒë∆∞·ª£c b·∫£o v·ªá
    return <WrappedComponent {...props} />;
  };
}
`.trim();
    
    createFileWithContent(authComponentPath, authComponentContent);
    log('‚úÖ ƒê√£ t·∫°o withAdminAuth component');
  } else {
    log('‚ö†Ô∏è File withAdminAuth component ƒë√£ t·ªìn t·∫°i, b·ªè qua');
  }
  
  log('‚úÖ ƒê√£ ho√†n t·∫•t vi·ªác s·ª≠a l·ªói withAdminAuth component');
}

// H√†m th·ª±c thi t·∫•t c·∫£ c√°c ch·ª©c nƒÉng s·ª≠a l·ªói
function runAllFixes() {
  log('üöÄ B·∫Øt ƒë·∫ßu th·ª±c hi·ªán t·∫•t c·∫£ c√°c b∆∞·ªõc s·ª≠a l·ªói...');
  
  try {
    // 1. Ki·ªÉm tra m√¥i tr∆∞·ªùng
    checkEnvironment();
    
    // 2. S·ª≠a l·ªói SWC
    fixSWCErrors();
    
    // 3. S·ª≠a l·ªói file trace
    fixTraceError();
    
    // 4. S·ª≠a l·ªói vendor chunks
    fixVendorChunks();
    
    // 5. S·ª≠a l·ªói manifest files
    fixManifestFiles();
    
    // 6. S·ª≠a l·ªói static files
    fixStaticFiles();
    
    // 7. S·ª≠a l·ªói static files c√≥ hash
    fixHashedStaticFiles();
    
    // 8. S·ª≠a l·ªói app routes
    fixAppRoutes();
    
    // 9. X√≥a cache
    clearCache();
    
    // 10. T·∫°o c√°c file .gitkeep
    createGitkeepFiles();
    
    // 11. C·∫≠p nh·∫≠t .gitignore
    updateGitignore();
    
    // 12. S·ª≠a l·ªói withAdminAuth component
    fixAuthComponent();
    
    log('‚úÖ ƒê√£ ho√†n t·∫•t t·∫•t c·∫£ c√°c b∆∞·ªõc s·ª≠a l·ªói');
    log('üöÄ Kh·ªüi ƒë·ªông l·∫°i ·ª©ng d·ª•ng ƒë·ªÉ √°p d·ª•ng thay ƒë·ªïi');
  } catch (error) {
    log(`‚ùå ƒê√£ x·∫£y ra l·ªói khi th·ª±c hi·ªán s·ª≠a l·ªói: ${error.message}`);
    log(error.stack);
  }
}

// Th·ª±c thi t·∫•t c·∫£ c√°c ch·ª©c nƒÉng s·ª≠a l·ªói
runAllFixes(); 