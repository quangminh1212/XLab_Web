/**
 * Script t·ªïng h·ª£p cho Next.js
 * - D·ªçn d·∫πp v√† s·ª≠a l·ªói t·ª± ƒë·ªông
 * - T·∫°o c·∫•u tr√∫c file t·ªëi thi·ªÉu cho .next
 * - X√≥a file t·∫°m th·ªùi
 * - T·ªëi ∆∞u h√≥a d·ª± √°n
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Thi·∫øt l·∫≠p
const VERBOSE = false; // True ƒë·ªÉ hi·ªÉn th·ªã t·∫•t c·∫£ log, False ƒë·ªÉ ch·ªâ hi·ªÉn th·ªã log quan tr·ªçng
const MIN_FILES_ONLY = true; // Ch·ªâ t·∫°o c√°c file t·ªëi thi·ªÉu c·∫ßn thi·∫øt
const CLEANUP_TEMP_FILES = true; // T·ª± ƒë·ªông x√≥a c√°c script t·∫°m th·ªùi sau khi ch·∫°y

// Danh s√°ch file t·∫°m th·ªùi s·∫Ω b·ªã x√≥a khi k·∫øt th√∫c
const TEMP_FILES = [
  'check-config.js',
  'restart-dev.js',
  'restart.bat',
  'restart.ps1',
  'check-fix.ps1', 
  'commit-changes.ps1'
];

// Ghi log
function log(message, isImportant = false) {
  if (VERBOSE || isImportant) {
    console.log(message);
  }
}

log('=== T·ªëi ∆∞u h√≥a d·ª± √°n Next.js ===', true);

// T·∫°o th∆∞ m·ª•c n·∫øu ch∆∞a t·ªìn t·∫°i
function ensureDirectoryExists(dirPath) {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
    log(`‚úÖ ƒê√£ t·∫°o th∆∞ m·ª•c: ${dirPath}`);
  }
}

// T·∫°o file v·ªõi n·ªôi dung
function createFileWithContent(filePath, content) {
  const dirPath = path.dirname(filePath);
  ensureDirectoryExists(dirPath);
  
  fs.writeFileSync(filePath, content);
  log(`‚úÖ ƒê√£ t·∫°o file: ${filePath}`);
}

// S·ª≠a l·ªói Next.js config ƒë·ªÉ t∆∞∆°ng th√≠ch v·ªõi phi√™n b·∫£n m·ªõi nh·∫•t
function fixNextConfig() {
  log('üîß Ki·ªÉm tra v√† s·ª≠a c·∫•u h√¨nh Next.js...', true);
  
  const configPath = path.join(__dirname, 'next.config.js');
  if (!fs.existsSync(configPath)) {
    log('‚ùå Kh√¥ng t√¨m th·∫•y file next.config.js', true);
    return;
  }
  
  // T·∫°o b·∫£n sao l∆∞u
  try {
    fs.copyFileSync(configPath, `${configPath}.bak`);
    log('‚úÖ ƒê√£ t·∫°o b·∫£n sao l∆∞u next.config.js.bak');
  } catch (err) {
    log(`‚ùå L·ªói khi t·∫°o b·∫£n sao l∆∞u: ${err.message}`, true);
  }
  
  // ƒê·ªçc n·ªôi dung file
  const configContent = fs.readFileSync(configPath, 'utf8');
  
  // Ki·ªÉm tra xem outputFileTracingExcludes c√≥ trong experimental kh√¥ng
  const hasExperimentalTracing = configContent.includes('experimental') && 
    configContent.includes('outputFileTracingExcludes') && 
    /experimental\s*:\s*{[^}]*outputFileTracingExcludes/.test(configContent);
  
  if (hasExperimentalTracing) {
    log('üîÑ ƒêang s·ª≠a c·∫•u h√¨nh next.config.js...', true);
    
    // Thay th·∫ø b·∫±ng c√°ch ƒë∆∞a outputFileTracingExcludes ra kh·ªèi experimental
    let newConfig = configContent;
    
    try {
      // Tr√≠ch xu·∫•t n·ªôi dung c·ªßa outputFileTracingExcludes
      const tracingMatch = /outputFileTracingExcludes\s*:\s*({[^}]*})/.exec(configContent);
      if (tracingMatch && tracingMatch[1]) {
        const tracingContent = tracingMatch[1];
        
        // X√≥a n√≥ kh·ªèi experimental
        newConfig = newConfig.replace(/(\s*outputFileTracingExcludes\s*:\s*{[^}]*}),?/g, '');
        
        // Th√™m n√≥ nh∆∞ m·ªôt t√πy ch·ªçn c·∫•p cao nh·∫•t
        newConfig = newConfig.replace(/(experimental\s*:\s*{[^}]*}\s*),?/g, '$1,\n  outputFileTracingExcludes: ' + tracingContent + ',\n  ');
        
        fs.writeFileSync(configPath, newConfig);
        log('‚úÖ ƒê√£ s·ª≠a c·∫•u h√¨nh next.config.js th√†nh c√¥ng', true);
      } else {
        log('‚ö†Ô∏è Kh√¥ng th·ªÉ t√¨m th·∫•y n·ªôi dung outputFileTracingExcludes', true);
      }
    } catch (err) {
      log(`‚ùå L·ªói khi s·ª≠a c·∫•u h√¨nh: ${err.message}`, true);
      // Kh√¥i ph·ª•c b·∫£n sao l∆∞u
      fs.copyFileSync(`${configPath}.bak`, configPath);
      log('‚ö†Ô∏è ƒê√£ kh√¥i ph·ª•c b·∫£n sao l∆∞u next.config.js', true);
    }
  } else {
    log('‚úÖ C·∫•u h√¨nh next.config.js ƒë√£ h·ª£p l·ªá', true);
  }
}

// X·ª≠ l√Ω file trace
function fixTraceFile() {
  log('üîç Ki·ªÉm tra v√† x·ª≠ l√Ω file trace...', true);
  
  const tracePath = path.join(__dirname, '.next', 'trace');
  if (fs.existsSync(tracePath)) {
    try {
      // ƒê·∫∑t l·∫°i quy·ªÅn truy c·∫≠p
      try {
        fs.chmodSync(tracePath, 0o666);
        log('‚úÖ ƒê√£ ƒë·∫∑t l·∫°i quy·ªÅn truy c·∫≠p cho file trace');
      } catch (chmodErr) {
        log(`‚ö†Ô∏è Kh√¥ng th·ªÉ ƒë·∫∑t l·∫°i quy·ªÅn truy c·∫≠p: ${chmodErr.message}`);
      }
      
      // X√≥a file trace
      try {
        fs.unlinkSync(tracePath);
        log('‚úÖ ƒê√£ x√≥a file trace th√†nh c√¥ng', true);
      } catch (unlinkErr) {
        log(`‚ùå Kh√¥ng th·ªÉ x√≥a file trace: ${unlinkErr.message}`, true);
        
        // Th·ª≠ ph∆∞∆°ng ph√°p kh√°c tr√™n Windows
        try {
          execSync('attrib -r -s -h .next\\trace');
          execSync('del /f /q .next\\trace');
          if (!fs.existsSync(tracePath)) {
            log('‚úÖ ƒê√£ x√≥a file trace th√†nh c√¥ng b·∫±ng CMD', true);
          }
        } catch (cmdErr) {
          log(`‚ùå V·∫´n kh√¥ng th·ªÉ x√≥a file trace, vui l√≤ng x√≥a th·ªß c√¥ng: ${cmdErr.message}`, true);
        }
      }
    } catch (error) {
      log(`‚ùå L·ªói khi x·ª≠ l√Ω file trace: ${error.message}`, true);
    }
  } else {
    log('‚úÖ Kh√¥ng t√¨m th·∫•y file trace, kh√¥ng c·∫ßn x·ª≠ l√Ω', true);
  }
}

// T·∫°o c·∫•u tr√∫c th∆∞ m·ª•c t·ªëi thi·ªÉu cho .next
function createMinimalNextStructure() {
  log('üìÅ T·∫°o c·∫•u tr√∫c th∆∞ m·ª•c t·ªëi thi·ªÉu cho Next.js...', true);
  
  const nextDir = path.join(__dirname, '.next');
  ensureDirectoryExists(nextDir);
  
  // T·∫°o c√°c th∆∞ m·ª•c c·ªët l√µi
  const coreDirs = [
    path.join(nextDir, 'cache'),
    path.join(nextDir, 'server'),
    path.join(nextDir, 'static'),
    path.join(nextDir, 'static', 'chunks'),
    path.join(nextDir, 'static', 'css'),
    path.join(nextDir, 'server', 'pages'),
    path.join(nextDir, 'server', 'chunks')
  ];
  
  coreDirs.forEach(dir => ensureDirectoryExists(dir));
  
  // T·∫°o file .gitkeep trong m·ªói th∆∞ m·ª•c
  coreDirs.forEach(dir => {
    const gitkeepPath = path.join(dir, '.gitkeep');
    if (!fs.existsSync(gitkeepPath)) {
      fs.writeFileSync(gitkeepPath, '');
    }
  });
  
  // T·∫°o c√°c file manifest c∆° b·∫£n
  createFileWithContent(
    path.join(nextDir, 'server', 'middleware-manifest.json'),
    JSON.stringify({ middleware: {}, functions: {}, version: 2 }, null, 2)
  );
  
  log('‚úÖ ƒê√£ t·∫°o xong c·∫•u tr√∫c th∆∞ m·ª•c t·ªëi thi·ªÉu', true);
}

// X√≥a cache v√† file t·∫°m th·ªùi
function cleanupProject() {
  log('üßπ ƒêang d·ªçn d·∫πp d·ª± √°n...', true);
  
  const nextDir = path.join(__dirname, '.next');
  
  // X√≥a cache
  const cacheDirs = [
    path.join(nextDir, 'cache'),
    path.join(nextDir, 'static', 'webpack')
  ];
  
  cacheDirs.forEach(dir => {
    if (fs.existsSync(dir)) {
      try {
        fs.rmSync(dir, { recursive: true, force: true });
        log(`‚úÖ ƒê√£ x√≥a th∆∞ m·ª•c cache: ${dir}`);
        ensureDirectoryExists(dir);
      } catch (err) {
        log(`‚ö†Ô∏è Kh√¥ng th·ªÉ x√≥a th∆∞ m·ª•c ${dir}: ${err.message}`);
      }
    }
  });
  
  // X√≥a c√°c file t·∫°m th·ªùi
  if (CLEANUP_TEMP_FILES) {
    TEMP_FILES.forEach(file => {
      const filePath = path.join(__dirname, file);
      if (fs.existsSync(filePath) && file !== 'fix-all-errors.js') {
        try {
          fs.unlinkSync(filePath);
          log(`‚úÖ ƒê√£ x√≥a file t·∫°m th·ªùi: ${file}`, true);
        } catch (err) {
          log(`‚ö†Ô∏è Kh√¥ng th·ªÉ x√≥a file ${file}: ${err.message}`);
        }
      }
    });
  }
  
  log('‚úÖ ƒê√£ ho√†n t·∫•t d·ªçn d·∫πp d·ª± √°n', true);
}

// C·∫≠p nh·∫≠t gitignore ƒë·ªÉ lo·∫°i tr·ª´ c√°c file t·∫°m th·ªùi
function updateGitignore() {
  log('üìù C·∫≠p nh·∫≠t .gitignore...', true);
  
  const gitignorePath = path.join(__dirname, '.gitignore');
  if (!fs.existsSync(gitignorePath)) {
    log('‚ùå Kh√¥ng t√¨m th·∫•y file .gitignore', true);
    return;
  }
  
  let gitignoreContent = fs.readFileSync(gitignorePath, 'utf8');
  
  // Danh s√°ch c√°c m·∫´u c·∫ßn th√™m v√†o .gitignore
  const ignorePatterns = [
    '# Temporary files',
    '/check-config.js',
    '/restart-dev.js',
    '/restart.bat',
    '/restart.ps1',
    '/check-fix.ps1',
    '/commit-changes.ps1',
    '/node_modules/.cache/',
    '/.next/cache/**/*',
    '/.next/trace*',
    '**/*.hot-update.*',
    '**/*.js.map'
  ];
  
  // Th√™m c√°c m·∫´u ch∆∞a c√≥ v√†o .gitignore
  let updated = false;
  ignorePatterns.forEach(pattern => {
    if (!gitignoreContent.includes(pattern)) {
      gitignoreContent += `\n${pattern}`;
      updated = true;
    }
  });
  
  if (updated) {
    fs.writeFileSync(gitignorePath, gitignoreContent);
    log('‚úÖ ƒê√£ c·∫≠p nh·∫≠t .gitignore', true);
  } else {
    log('‚úÖ .gitignore ƒë√£ ch·ª©a t·∫•t c·∫£ c√°c m·∫´u c·∫ßn thi·∫øt', true);
  }
}

// T·∫°o file run.bat ƒë∆°n gi·∫£n
function createRunScript() {
  log('üìÑ T·∫°o file run.bat ƒë∆°n gi·∫£n...', true);
  
  const runBatContent = `@echo off
echo ===========================================================
echo Starting Next.js application - XLab_Web
echo ===========================================================

REM Ki·ªÉm tra v√† x·ª≠ l√Ω file trace
if exist ".next\\trace" (
  echo Fixing trace file...
  attrib -r -s -h .next\\trace
  del /f /q .next\\trace
)

REM Kh·ªüi ƒë·ªông ·ª©ng d·ª•ng
echo Starting Next.js application...
npm run dev

pause`;
  
  const runBatPath = path.join(__dirname, 'run.bat');
  fs.writeFileSync(runBatPath, runBatContent);
  log('‚úÖ ƒê√£ t·∫°o file run.bat th√†nh c√¥ng', true);
}

// Ch·∫°y t·∫•t c·∫£ c√°c ch·ª©c nƒÉng
async function main() {
  try {
    log('üöÄ B·∫Øt ƒë·∫ßu qu√° tr√¨nh t·ªëi ∆∞u h√≥a...', true);
    
    // X·ª≠ l√Ω file trace
    fixTraceFile();
    
    // S·ª≠a c·∫•u h√¨nh Next.js
    fixNextConfig();
    
    // T·∫°o c·∫•u tr√∫c th∆∞ m·ª•c t·ªëi thi·ªÉu
    createMinimalNextStructure();
    
    // D·ªçn d·∫πp d·ª± √°n
    cleanupProject();
    
    // C·∫≠p nh·∫≠t gitignore
    updateGitignore();
    
    // T·∫°o file run.bat ƒë∆°n gi·∫£n
    createRunScript();
    
    log('‚úÖ ƒê√£ ho√†n t·∫•t qu√° tr√¨nh t·ªëi ∆∞u h√≥a!', true);
    log('üöÄ Ch·∫°y file run.bat ƒë·ªÉ kh·ªüi ƒë·ªông d·ª± √°n', true);
  } catch (error) {
    log(`‚ùå L·ªói trong qu√° tr√¨nh t·ªëi ∆∞u h√≥a: ${error.message}`, true);
    log(`Stack: ${error.stack}`, true);
  }
}

// Ch·∫°y ch∆∞∆°ng tr√¨nh
main(); 